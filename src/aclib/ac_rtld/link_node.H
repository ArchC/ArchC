/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */

/**
 * @file      link_node.H
 * @author    Rafael Auler
 *
 * @author    The ArchC Team
 *            http://www.archc.org/
 *
 *            Computer Systems Laboratory (LSC)
 *            IC-UNICAMP
 *            http://www.lsc.ic.unicamp.br/
 *
 * @version   1.0
 * @date      Mon, 19 Jun 2006 15:33:19 -0300
 *
 * @brief     ArchC runtime dynamic linker main structure.
 *            Stores a linking unit (object file) and
 *            provides methods to relocate and bind
 *            symbols.
 *
 * @attention Copyright (C) 2002-2009 --- The ArchC Team
 *
 */


#ifndef _LINK_NODE_H
#define _LINK_NODE_H

//Fix for Cygwin users, that do not have elf.h
#ifdef __CYGWIN__
#include "elf32-tiny.h"
#else
#include <elf.h>
#endif /* __CYGWIN__ */

#include "dynamic_info.H"
#include "dynamic_symbol_table.H"
#include "dynamic_relocations.H"


namespace ac_dynlink {

  /* Forward class declarations */
  class version_needed;
  class memmap;


  /* Class is a node of a linked list representing the loaded libraries and
     application executable file. */
  class link_node {
  private:
    link_node *next;
    link_node *root;
    dynamic_info dyn_info;
    dynamic_symbol_table dyn_table;
    dynamic_relocations dyn_relocs;
    Elf32_Addr load_addr;
    unsigned int type;
    unsigned int needed_is_loaded;
    unsigned int has_relocations;
    unsigned char *soname;
    bool match_endian;
  public:
    link_node(link_node *r);

    void set_root (link_node *r);

    link_node *get_root ();

    unsigned char * get_soname();

    Elf32_Sym *lookup_local_symbol(unsigned int hash, unsigned char *name,
                                   char *vername, Elf32_Word verhash);

    bool link_node_setup(Elf32_Addr dynaddr, unsigned char *mem,
			 Elf32_Addr l_addr, unsigned int t, unsigned char *name,
                         version_needed *verneed, bool match_endian);

    link_node * get_next();

    void set_next(link_node *n);

    link_node * new_node();

    void load_needed (memmap *mem_map, unsigned char *mem, Elf32_Word mem_size);

    void adjust_symbols(unsigned char *mem) ;

    Elf32_Sym * find_symbol(unsigned char *name, char *vername, Elf32_Word verhash, bool exclude_root);

    void resolve_symbols() ;

    Elf32_Addr find_copy_relocation(unsigned char *symname);

    void patch_code(unsigned char *location, Elf32_Addr data, unsigned char target_size);

    void apply_relocations(unsigned char *mem, unsigned char word_size);
    
  };

}

#endif
