NOTES ABOUT THE ACTSIM TOOL

 The simulators for behavioral and cycle-accurate models are now generated by
different tools: the usual acsim only generates simulators for behavioral
models, and the actsim tool is used for cycle-accurate models. This document
describes some key points on the use of actsim.

1. Registers and formatted registers are synchronous

 This means that writes will only take effect at the end of each cycle, and the
delay (-dy) option is obsolete for actsim. Instruction behaviors are executed
during the evaluate phase, whereas register updates take place during the
update phase. If multiple writes occur at a cycle, only the most recent one
will be effective. The update phase of any particular register can be disabled
until the next cycle by means of the suspend method. A convenience suspend
method is provided for formatted registers, disabling the update phase of all
fields at once. The effects of the suspend method cannot be undone.

Assume that ID_EX is the name of a formatted register for this code example:

 ac_pc.suspend(); // disables updating of ac_pc at the end of the current cycle
 ID_EX.suspend(); // disables updating of all ID_EX fields

 Chained assignments should be done very carefully, since the value assigned to
a synchronous register is not readily avaliable, and thus reading from a
register that was just assigned to will wield the old value.

 In addition to fields of formatted registers, anything declared with ac_reg in
the architecture description file and also ac_pc are synchronous registers.

 Finally, this does not apply to registers in register banks.

2. Stalling and flushing

 Firstly, the ac_stall and ac_flush methods have been obsoleted. That being
said, stalling does not automatically suspend formatted registers used to
transmit data between stages: these suspend calls should be done manually.

 Methods for asking a pipeline stage whether it will stall or flush or it is
currently stalled are provided. However, the reliability of these answers when
a behavior being executed in one stage asks about a different stage is subject
to stage serialization, which should not be taken for granted. It is safe to
ask about the same stage, though (the need for this might arise, for example,
if a more specific behavior needs to know whether a more general behavior
caused a stall). In the future, a behavior method unrelated to instruction
behaviors will be provided where the answers about all stages are reliable.

Assume that G_ID is the name of a stage, and IF_ID and ID_EX are names of
formatted registers for these code examples:

 if ((ID_EX.regwrite == 1) && ((ID_EX.rd == rs) || (ID_EX.rt == rs)))
 {
  G_ID.stall();
  IF_ID.suspend();
  ID_EX.regwrite = 0;
 }

 if (!G_ID.will_flush())
 {
  // some code
 }

 if (G_ID.will_stall())
 {
  // some code

 if (G_ID.is_stalled())
 {
  // some code
 }

3. ac_stage is deprecated

 Using ac_pipe to declare pipelines in the architecture description file is
encouraged. Pipeline stages declared with ac_stage are treated by actsim as
stages of a single unnamed pipeline. See next item.

4. Pipeline stage naming convention

 Pipeline stages now have a name in the pipename_stagename format regardless of
a single pipeline existing. If ac_stage was used, "pipename" will be considered
to be an empty string and therefore the names of the stages will be in the
_stagename format.

 Due to pipeline stages being exposed as objects to the behavior methods, the
stage id constants (used inside the switch blocks generated in the ISA
implementation template) had the prefix "id_" added to them.

5. Headers

 The stage headers now must be directly included in the ISA implementation file
if the model is to use the exposed stages in any way, such as stalling,
flushing or querying the stall/flush state.

6. Stage serialization

 While no truly parallel execution can occur at this point, stages are no
longer serialized in reverse order of declaration as it used to be until ArchC
1.6. Failure to account for this when developing a model might lead to errors
related to true data dependencies.

7. Features not yet working

- TLM
- multiple instances of simulators
- multiple pipelines

All the best,
 - The ArchC Team

