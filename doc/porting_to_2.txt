HOW-TO: CONVERTING YOUR ARCHC 1.6.x MODEL TO 2.0
------------------------------------------------

Follow those 9 steps:

1. Change modelname-isa.cpp to modelname_isa.cpp


2. Edit modelname_isa.cpp so that it includes these headers:
#include  "modelname_isa.H"
#include  "modelname_isa_init.cpp"
#include  "modelname_bhv_macros.H"


3. Add:
using namespace modelname_parms;

   to your modelname_isa.cpp, modelname_gdb_funcs.cpp and
   modelname_syscall.cpp files. This is necessary because all the
   processor specific types like ac_word and ac_Hword etc are now
   contained on a namespace relating them to the processor model,
   avoiding type clashes in projects including more than one different
   processor models.


4. In your modelname_isa.cpp, modelname_gdb_funcs.cpp and
   modelname_syscall.cpp files, there's a chance that some
   architectural elements from the model, like a data memory DM, are
   being accessed like this:
ac_resources::DM.something();

   If this is the case, you can safely remove every occurrence of
   'ac_resources::' in your files because ArchC 2.0 was constructed so
   that every implementation of instruction behaviors, GDB functions
   or syscall helper functions have direct visibility of all
   architectural elements. So the correct version of the DM example
   looks like this:
DM.something();

   Isn't it so much cleaner? :-)


5. Your modelname_isa.cpp, modelname_gdb_funcs.cpp and
   modelname_syscall.cpp files might be including
   "ac_resources.H". This will cause a compilation error (since acsim
   no longer generates an ac_resources.H file nor an ac_resources
   class; the architectural elements now appear as non-static members
   of the modelname_arch class), so you must remove the:
#include "ac_resources.H"

   line from all those files.


6. In your modelname_isa.cpp, modelname_gdb_funcs.cpp and
   modelname_syscall.cpp files, replace every call to the 'ac_stop()'
   function to 'stop()'. There's no need to change the parameters, it
   was a simple function renaming.


7. If your modelname_isa.cpp file has global functions, you might have
   to modify them. Whatever element you want to access inside of them,
   that wasn't passed as a parameter, will be out of scope because
   architectural elements are not global anymore. The easiest way of
   solving the problem of access to the architectural elements is
   passing them by reference as a function parameter, and then
   changing all the calls to the function to pass those extra
   parameters you just added (which is easily done via the
   search-and-replace feature of your favourite editor). Let's take a
   look at how this was done on the SPARC V8 model:

   We changed:
inline void update_pc(bool branch, bool taken, bool b_always, bool annul,
                      ac_word addr)

   To add an extra ac_pc reference parameter:
inline void update_pc(bool branch, bool taken, bool b_always, bool annul,
                      ac_word addr, ac_reg<unsigned>& ac_pc)

   And every occurrence of:
update_pc(a, b, c, d, e)

   To pass the extra ac_pc parameter by reference:
update_pc(a, b, c, d, e, ac_pc)

   To verify of what type those elements are (like, in this case,
   ac_pc, which is of type ac_reg<unsigned>), take a look at ac_arch.H
   (an ArchC library include file) or modelname_arch.H (generated by
   acsim), which contain the declarations for the elements you want
   (the elements common to all processor models are members of the
   ac_arch class, whether the specific ones, such as most of those you
   declared on the AC file, are members of modelname_arch).

   If you're writing a new model from scratch, please remember that
   using global functions with side-effects in methods of a class
   which will be instantiated more than once is usually indicative of
   not-so-great programming. And it's the fact why we're supplying
   this step 7, which was entirely avoided in the porting of models
   that didn't use such global functions (like mips1, for example).


8. In your modelname_isa.cpp, modelname_gdb_funcs.cpp and
   modelname_syscall.cpp files, there's a chance some of the
   instruction behavior or helper methods declared on them might use
   variables or constants as 'extern'. If those are either
   architectural resources or constants from the parms file (which
   comprehend all of the cases we've seen so far), you're absolutely
   free to remove the extern line completely, because such variables
   or constants are already visible to those methods.

   Here's one example from our SPARC V8 model. In the file
   sparcv8_syscall.cpp, we had the line:
extern const unsigned AC_RAM_END;

   Inside the sparcv8_syscall::set_prog_args() method. We removed this
   extern line completely because AC_RAM_END is already visible to the
   method, so there's no need for extern (which indicates cleaner
   coding, since using lots of externs is quite inelegant).


9. There's a chance your model has global variables, most probably
   defined on modelname_isa.cpp (like in our SPARC V8 model: they're
   defined on sparcv8_isa.cpp) or on one of the other cpp files. Now,
   global variables present two serious problems. The first of them is
   that they're really ugly. People shouldn't use them when they don't
   need them. The second problem is much more serious: they make it
   completely impossible to run more than a single instance of your
   processor model.

   That's right: the global variables alone won't keep your model from
   compiling, but since they're global, there will always be only one
   instance of each of them, which will be a major problem if you want
   to use multiple instances of the simulator generated by acsim in,
   for instance, an multiprocessor SoC model.

   The solution we suggest is exactly the same we used in porting our
   SPARC V8 model: converting all those global variables to
   registers. As an example, in the sparcv8_isa.cpp file we had those:
unsigned char CWP = 0xF0;     //Current window pointer
unsigned char WIM = 0x00;     //Window invalid bit (points to the invalid reg window)

   We removed those declarations from that file and added register
   declarations to sparcv8.ac, like this:
ac_reg<8> CWP;
ac_reg<8> WIM;

   With this modification, no other line of the sparcv8_isa.cpp had to
   be modified, because those registers can be accessed or used in the
   exact same way the unsigned char variables were. Also, notice that
   ac_regs now can have their width specified inside angle brackets
   (which were previously used only to specify the format, when you
   wanted to use a formatted register). That's right, this is a new
   feature of ArchC 2.0, because in 1.6.x every register you declared
   had the same width specified by ac_wordsize, meaning you couldn't
   declare a register with width different from the word size. But now
   you can, in 2.0.

   On a side note, if you had global variables of type bool, for flags
   or something like that, and you want your ac_regs to behave exactly
   like the global variables they're substituting, you can do that,
   declaring them as ac_reg<1>.

   Of course, the removal of global variables, converting them to
   registers, leads to the need of three other collateral
   modifications.

   The first of them is removing the stray externs: there's a chance
   that variables declared on one cpp file are being accessed on other
   file, so you'll have to remove the extern statements from those
   other files.

   Another modification is needed when those global variables were
   initialized with a value different from zero. Such is the case of
   the SPARC V8 CWP register shown above. Since every ac_reg is
   initialized to zero at construction time, if you want them to have
   another value when the processor starts running, you should put
   such initialization at the *begin* ac_behavior. This is what we've
   done with the SPARC V8 model:
void ac_behavior(begin)
{
  dbg_printf("@@@ begin behavior @@@\n");
  REGS[0] = 0;  //writeReg can't initialize register 0
  npc = ac_pc + 4;

  CWP = 0xF0; // Added this line.
}

   The third and perhaps more important modification is converting
   whatever global function that modified global variables as their
   side-effect to receive those variables (which have now became
   registers) as reference parameters. The procedure is exactly the
   same as detailed on step 7, and it's needed for pretty much the
   same reasons: what once were global variables now are fields of an
   object, so you need their reference to modify them.

   For example, our SPARC V8 had an npc global variable that we
   modified to become a register (which is much saner), and since the
   global function update_pc() modified npc, we had to pass it as an
   extra reference parameter. So we essentially changed:
inline void update_pc(bool branch, bool taken, bool b_always, bool annul,
                      ac_word addr, ac_reg<unsigned>& ac_pc)

To include npc as one of the parameters:
inline void update_pc(bool branch, bool taken, bool b_always, bool annul,
                      ac_word addr, ac_reg<unsigned>& ac_pc,
                      ac_reg<ac_word>& npc)

   Following this, we had to do a search-and-replace in the rest of
   the code to change every occurrence of:
update_pc(a, b, c, d, e, ac_pc)

   to pass the extra npc parameter:
update_pc(a, b, c, d, e, ac_pc, npc)


10. If you've made all the modifications detailed in these 9 steps,
    then congratulations, you should have an ArchC 2.0 compliant
    model. Of course, some models are far easier to port to 2.0 than
    others. The mips1 model, for instance, was incredibly easy to
    port, requiring only 15 minutes at most, and being guided only by
    the compiler error messages, instead of this guide. It didn't
    require the steps 7 to 9, which would definitely make the process
    trickier. Another model, sparcv8, on the other hand, required all
    of those steps, but even so was fast to port.

    However, if you have thoroughly made all those modifications to
    your model and it still doesn't work in 2.0 (but it did in 1.6),
    feel free to contact us in the forums. If you realize that we
    goofed up, forgetting a more complicated compatibility problem
    between 1.6 and 2.0, please tell us so, as we'll be delighted to
    know and therefore use the good news to update this document.

All the best,

 -- The ArchC Team.
