/********************************************************/
/* The ArchC MIPS-I functional model.                   */
/* Author: Sandro Rigo and Marcus Bartholomeu           */
/*                                                      */
/* This file is automatically generated by ArchC        */
/* WITHOUT WARRANTY OF ANY KIND, either express         */
/* or implied.                                          */
/* For more information on ArchC, please visit:         */
/* http://www.archc.org                                 */
/*                                                      */
/* The ArchC Team                                       */
/* Computer Systems Laboratory (LSC)                    */
/* IC-UNICAMP                                           */
/* http://www.lsc.ic.unicamp.br                         */
/********************************************************/
#include  "mips1_isa.H"
#include  "mips1_isa_init.cpp"
#include  "mips1_bhv_macros.H"

//If you want debug information for this model, uncomment next line
//#define DEBUG_MODEL

#ifdef DEBUG_MODEL
#include <stdio.h>
#include <stdarg.h>
inline int dprintf(const char *format, ...)
{
  int ret;
  va_list args;
  va_start(args, format);
  ret = vfprintf(ac_err, format, args);
  va_end(args);
  return ret;
}
#else
inline void dprintf(const char *format, ...) {}
#endif


//!User defined macros to reference registers.
#define Ra 31
#define Sp 29
#define Hi 32
#define Lo 33

 
//!Generic instruction behavior method.
void ac_behavior( instruction )
{ 
  dprintf("----- PC=%#x ----- %lld\n", (int) ac_pc, ac_instr_counter);
#ifndef NO_NEED_PC_UPDATE
  ac_pc = ac_pc +4;
#endif 
};
 
//! Instruction Format behavior methods.
void ac_behavior( Type_R ){}
void ac_behavior( Type_I ){}
void ac_behavior( Type_J ){}
 
//!Behavior called before starting simulation
void ac_behavior(begin)
{
  dprintf("@@@ begin behavior @@@\n");
  RB.write(0,0);
}

//!Behavior called after finishing simulation
void ac_behavior(end)
{
  dprintf("@@@ end behavior @@@\n");
}


//!Instruction lb behavior method.
void ac_behavior( lb )
{
  char byte;
  dprintf("lb r%d, %d(r%d)\n", rt, imm & 0xFFFF, rs);
  byte = DM.read_byte(RB.read(rs)+ imm);
  RB.write(rt, (mips1_parms::ac_Sword)byte );
  dprintf("Result = %#x\n", RB.read(rt));
};

//!Instruction lbu behavior method.
void ac_behavior( lbu )
{
  unsigned char byte;
  dprintf("lbu r%d, %d(r%d)\n", rt, imm & 0xFFFF, rs);
  byte = DM.read_byte(RB.read(rs)+ imm);
  RB.write(rt, byte );
  dprintf("Result = %#x\n", RB.read(rt));
};

//!Instruction lh behavior method.
void ac_behavior( lh )
{
  short int half;
  dprintf("lh r%d, %d(r%d)\n", rt, imm & 0xFFFF, rs);
  half = DM.read_half(RB.read(rs)+ imm);
  RB.write(rt, (mips1_parms::ac_Sword)half );
  dprintf("Result = %#x\n", RB.read(rt));
};

//!Instruction lhu behavior method.
void ac_behavior( lhu )
{
  unsigned short int  half;
  half = DM.read_half(RB.read(rs)+ imm);
  RB.write(rt, half );
  dprintf("Result = %#x\n", RB.read(rt));
};

//!Instruction lw behavior method.
void ac_behavior( lw )
{
  dprintf("lw r%d, %d(r%d)\n", rt, imm & 0xFFFF, rs);
  RB.write(rt, DM.read(RB.read(rs)+ imm));
  dprintf("Result = %#x\n", RB.read(rt));
};

//!Instruction lwl behavior method.
void ac_behavior( lwl )
{
  dprintf("lwl r%d, %d(r%d)\n", rt, imm & 0xFFFF, rs);
  unsigned int addr, offset;
  mips1_parms::ac_Uword data;

  addr = RB.read(rs) + imm;
  offset = (addr & 0x3) * 8;
  data = DM.read(addr & 0xFFFFFFFC);
  data <<= offset;
  data |= RB.read(rt) & ((1<<offset)-1);
  RB.write(rt, data);
  dprintf("Result = %#x\n", RB.read(rt));
};

//!Instruction lwr behavior method.
void ac_behavior( lwr )
{
  dprintf("lwr r%d, %d(r%d)\n", rt, imm & 0xFFFF, rs);
  unsigned int addr, offset;
  mips1_parms::ac_Uword data;

  addr = RB.read(rs) + imm;
  offset = (3 - (addr & 0x3)) * 8;
  data = DM.read(addr & 0xFFFFFFFC);
  data >>= offset;
  data |= RB.read(rt) & (0xFFFFFFFF << (32-offset));
  RB.write(rt, data);
  dprintf("Result = %#x\n", RB.read(rt));
};

//!Instruction sb behavior method.
void ac_behavior( sb )
{
  unsigned char byte;
  dprintf("sb r%d, %d(r%d)\n", rt, imm & 0xFFFF, rs);
  byte = RB.read(rt) & 0xFF;
  DM.write_byte(RB.read(rs) + imm, byte);
  dprintf("Result = %#x\n", (int) byte);
};

//!Instruction sh behavior method.
void ac_behavior( sh )
{
  unsigned short int half;
  dprintf("sh r%d, %d(r%d)\n", rt, imm & 0xFFFF, rs);
  half = RB.read(rt) & 0xFFFF;
  DM.write_half(RB.read(rs) + imm, half);
  dprintf("Result = %#x\n", (int) half);
};

//!Instruction sw behavior method.
void ac_behavior( sw )
{
  dprintf("sw r%d, %d(r%d)\n", rt, imm & 0xFFFF, rs);
  DM.write(RB.read(rs) + imm, RB.read(rt));
  dprintf("Result = %#x\n", RB.read(rt));
};

//!Instruction swl behavior method.
void ac_behavior( swl )
{
  dprintf("swl r%d, %d(r%d)\n", rt, imm & 0xFFFF, rs);
  unsigned int addr, offset;
  mips1_parms::ac_Uword data;

  addr = RB.read(rs) + imm;
  offset = (addr & 0x3) * 8;
  data = RB.read(rt);
  data >>= offset;
  data |= DM.read(addr & 0xFFFFFFFC) & (0xFFFFFFFF << (32-offset));
  DM.write(addr & 0xFFFFFFFC, data);
  dprintf("Result = %#x\n", data);
};

//!Instruction swr behavior method.
void ac_behavior( swr )
{
  dprintf("swr r%d, %d(r%d)\n", rt, imm & 0xFFFF, rs);
  unsigned int addr, offset;
  mips1_parms::ac_Uword data;

  addr = RB.read(rs) + imm;
  offset = (3 - (addr & 0x3)) * 8;
  data = RB.read(rt);
  data <<= offset;
  data |= DM.read(addr & 0xFFFFFFFC) & ((1<<offset)-1);
  DM.write(addr & 0xFFFFFFFC, data);
  dprintf("Result = %#x\n", data);
};

//!Instruction addi behavior method.
void ac_behavior( addi )
{
  dprintf("addi r%d, r%d, %d\n", rt, rs, imm & 0xFFFF);
  RB.write(rt, RB.read(rs) + imm);
  dprintf("Result = %#x\n", RB.read(rt));
  //Test overflow
  if ( ((RB.read(rs) & 0x80000000) == (imm & 0x80000000)) &&
       ((imm & 0x80000000) != (RB.read(rt) & 0x80000000)) ) {
    fprintf(stderr, "EXCEPTION(addi): integer overflow.\n"); exit(EXIT_FAILURE);
  }
};

//!Instruction addiu behavior method.
void ac_behavior( addiu )
{
  dprintf("addiu r%d, r%d, %d\n", rt, rs, imm & 0xFFFF);
  RB.write(rt, RB.read(rs) + imm);
  dprintf("Result = %#x\n", RB.read(rt));
};

//!Instruction slti behavior method.
void ac_behavior( slti )
{
  dprintf("slti r%d, r%d, %d\n", rt, rs, imm & 0xFFFF);
  // Set the RD if RS< IMM
  if( (mips1_parms::ac_Sword) RB.read(rs) < (mips1_parms::ac_Sword) imm )
    RB.write(rt,1);
  // Else reset RD
  else
    RB.write(rt,0);
  dprintf("Result = %#x\n", RB.read(rt));
};

//!Instruction sltiu behavior method.
void ac_behavior( sltiu )
{
  dprintf("sltiu r%d, r%d, %d\n", rt, rs, imm & 0xFFFF);
  // Set the RD if RS< IMM
  if( (mips1_parms::ac_Uword) RB.read(rs) < (mips1_parms::ac_Uword) imm )
    RB.write(rt, 1);
  // Else reset RD
  else
    RB.write(rt, 0);
  dprintf("Result = %#x\n", RB.read(rt));
};

//!Instruction andi behavior method.
void ac_behavior( andi )
{	
  dprintf("andi r%d, r%d, %d\n", rt, rs, imm & 0xFFFF);
  RB.write(rt, RB.read(rs) & (imm & 0xFFFF) );
  dprintf("Result = %#x\n", RB.read(rt));
};

//!Instruction ori behavior method.
void ac_behavior( ori )
{	
  dprintf("ori r%d, r%d, %d\n", rt, rs, imm & 0xFFFF);
  RB.write(rt, RB.read(rs) | (imm & 0xFFFF) );
  dprintf("Result = %#x\n", RB.read(rt));
};

//!Instruction xori behavior method.
void ac_behavior( xori )
{	
  dprintf("xori r%d, r%d, %d\n", rt, rs, imm & 0xFFFF);
  RB.write(rt, RB.read(rs) ^ (imm & 0xFFFF) );
  dprintf("Result = %#x\n", RB.read(rt));
};

//!Instruction lui behavior method.
void ac_behavior( lui )
{	
  dprintf("lui r%d, r%d, %d\n", rt, rs, imm & 0xFFFF);
  // Load a constant in the upper 16 bits of a register
  // To achieve the desired behaviour, the constant was shifted 16 bits left
  // and moved to the target register ( rt )
  RB.write(rt,  imm << 16);
  dprintf("Result = %#x\n", RB.read(rt));
};

//!Instruction add behavior method.
void ac_behavior( add )
{
  dprintf("add r%d, r%d, r%d\n", rd, rs, rt);
  RB.write(rd, RB.read(rs) + RB.read(rt));
  dprintf("Result = %#x\n", RB.read(rd));
  //Test overflow
  if ( ((RB.read(rs) & 0x80000000) == (RB.read(rd) & 0x80000000)) &&
       ((RB.read(rd) & 0x80000000) != (RB.read(rt) & 0x80000000)) ) {
    fprintf(stderr, "EXCEPTION(add): integer overflow.\n"); exit(EXIT_FAILURE);
  }
};

//!Instruction addu behavior method.
void ac_behavior( addu )
{
  dprintf("addu r%d, r%d, r%d\n", rd, rs, rt);
  RB.write(rd, RB.read(rs) + RB.read(rt));
  //cout << "  RS: " << (unsigned int)RB.read(rs) << " RT: " << (unsigned int)RB.read(rt) << endl;
  //cout << "  Result =  " <<  (unsigned int)RB.read(rd) <<endl;
  dprintf("Result = %#x\n", RB.read(rd));
};

//!Instruction sub behavior method.
void ac_behavior( sub )
{
  dprintf("sub r%d, r%d, r%d\n", rd, rs, rt);
  RB.write(rd, RB.read(rs) - RB.read(rt));
  dprintf("Result = %#x\n", RB.read(rd));
  //TODO: test integer overflow exception for sub
};

//!Instruction subu behavior method.
void ac_behavior( subu )
{
  dprintf("subu r%d, r%d, r%d\n", rd, rs, rt);
  RB.write(rd, RB.read(rs) - RB.read(rt));
  dprintf("Result = %#x\n", RB.read(rd));
};

//!Instruction slt behavior method.
void ac_behavior( slt )
{	
  dprintf("slt r%d, r%d, r%d\n", rd, rs, rt);
  // Set the RD if RS< RT
  if( (mips1_parms::ac_Sword) RB.read(rs) < (mips1_parms::ac_Sword) RB.read(rt) )
    RB.write(rd,1);
  // Else reset RD
  else
    RB.write(rd,0);
  dprintf("Result = %#x\n", RB.read(rd));
};

//!Instruction sltu behavior method.
void ac_behavior( sltu )
{
  dprintf("sltu r%d, r%d, r%d\n", rd, rs, rt);
  // Set the RD if RS < RT
  if( RB.read(rs) < RB.read(rt) )
    RB.write(rd, 1);
  // Else reset RD
  else
    RB.write(rd, 0);
  dprintf("Result = %#x\n", RB.read(rd));
};

//!Instruction instr_and behavior method.
void ac_behavior( instr_and )
{
  dprintf("instr_and r%d, r%d, r%d\n", rd, rs, rt);
  RB.write(rd, RB.read(rs) & RB.read(rt));
  dprintf("Result = %#x\n", RB.read(rd));
};

//!Instruction instr_or behavior method.
void ac_behavior( instr_or )
{
  dprintf("instr_or r%d, r%d, r%d\n", rd, rs, rt);
  RB.write(rd, RB.read(rs) | RB.read(rt));
  dprintf("Result = %#x\n", RB.read(rd));
};

//!Instruction instr_xor behavior method.
void ac_behavior( instr_xor )
{
  dprintf("instr_xor r%d, r%d, r%d\n", rd, rs, rt);
  RB.write(rd, RB.read(rs) ^ RB.read(rt));
  dprintf("Result = %#x\n", RB.read(rd));
};

//!Instruction instr_nor behavior method.
void ac_behavior( instr_nor )
{
  dprintf("nor r%d, r%d, r%d\n", rd, rs, rt);
  RB.write(rd, ~(RB.read(rs) | RB.read(rt)));
  dprintf("Result = %#x\n", RB.read(rd));
};

//!Instruction nop behavior method.
void ac_behavior( nop )
{  
  dprintf("nop\n");
};

//!Instruction sll behavior method.
void ac_behavior( sll )
{  
  dprintf("sll r%d, r%d, %d\n", rd, rs, shamt);
  RB.write(rd, RB.read(rt) << shamt);
  dprintf("Result = %#x\n", RB.read(rd));
};

//!Instruction srl behavior method.
void ac_behavior( srl )
{
  dprintf("srl r%d, r%d, %d\n", rd, rs, shamt);
  RB.write(rd, RB.read(rt) >> shamt);
  dprintf("Result = %#x\n", RB.read(rd));
};

//!Instruction sra behavior method.
void ac_behavior( sra )
{
  dprintf("sra r%d, r%d, %d\n", rd, rs, shamt);
  RB.write(rd, (mips1_parms::ac_Sword) RB.read(rt) >> shamt);
  dprintf("Result = %#x\n", RB.read(rd));
};

//!Instruction sllv behavior method.
void ac_behavior( sllv )
{
  dprintf("sllv r%d, r%d, r%d\n", rd, rt, rs);
  RB.write(rd, RB.read(rt) << (RB.read(rs) & 0x1F));
  dprintf("Result = %#x\n", RB.read(rd));
};

//!Instruction srlv behavior method.
void ac_behavior( srlv )
{
  dprintf("srlv r%d, r%d, r%d\n", rd, rt, rs);
  RB.write(rd, RB.read(rt) >> (RB.read(rs) & 0x1F));
  dprintf("Result = %#x\n", RB.read(rd));
};

//!Instruction srav behavior method.
void ac_behavior( srav )
{
  dprintf("srav r%d, r%d, r%d\n", rd, rt, rs);
  RB.write(rd, (mips1_parms::ac_Sword) RB.read(rt) >> (RB.read(rs) & 0x1F));
  dprintf("Result = %#x\n", RB.read(rd));
};

//!Instruction mult behavior method.
void ac_behavior( mult )
{
  dprintf("mult r%d, r%d\n", rs, rt);

  long long result;
  int half_result;

  result = (mips1_parms::ac_Sword) RB.read(rs);
  result *= (mips1_parms::ac_Sword) RB.read(rt);

  half_result = (result & 0xFFFFFFFF);
  // Register LO receives 32 less significant bits
  RB.write(Lo, half_result);

  half_result = ((result >> 32) & 0xFFFFFFFF);
  // Register HI receives 32 most significant bits
  RB.write(Hi, half_result );

  dprintf("Result = %#llx\n", result);
};

//!Instruction multu behavior method.
void ac_behavior( multu )
{
  dprintf("multu r%d, r%d\n", rs, rt);

  unsigned long long result;
  unsigned int half_result;

  result  = RB.read(rs);
  result *= RB.read(rt);

  half_result = (result & 0xFFFFFFFF);
  // Register LO receives 32 less significant bits
  RB.write(Lo, half_result);

  half_result = ((result>>32) & 0xFFFFFFFF);
  // Register HI receives 32 most significant bits
  RB.write(Hi, half_result );

  dprintf("Result = %#llx\n", result);
};

//!Instruction div behavior method.
void ac_behavior( div )
{
  dprintf("div r%d, r%d\n", rs, rt);
  // Register LO receives quotient
  RB.write(Lo, (mips1_parms::ac_Sword) RB.read(rs) / (mips1_parms::ac_Sword) RB.read(rt));
  // Register HI receives remainder
  RB.write(Hi, (mips1_parms::ac_Sword) RB.read(rs) % (mips1_parms::ac_Sword) RB.read(rt));
};

//!Instruction divu behavior method.
void ac_behavior( divu )
{
  dprintf("divu r%d, r%d\n", rs, rt);
  // Register LO receives quotient
  RB.write(Lo, RB.read(rs) / RB.read(rt));
  // Register HI receives remainder
  RB.write(Hi, RB.read(rs) % RB.read(rt));
};

//!Instruction mfhi behavior method.
void ac_behavior( mfhi )
{
  dprintf("mfhi r%d\n", rd);
  RB.write(rd, RB.read(Hi));
  dprintf("Result = %#x\n", RB.read(rd));
};

//!Instruction mthi behavior method.
void ac_behavior( mthi )
{
  dprintf("mthi r%d\n", rs);
  RB.write(Hi, RB.read(rs));
  dprintf("Result = %#x\n", RB.read(Hi));
};

//!Instruction mflo behavior method.
void ac_behavior( mflo )
{
  dprintf("mflo r%d\n", rd);
  RB.write(rd, RB.read(Lo));
  dprintf("Result = %#x\n", RB.read(rd));
};

//!Instruction mtlo behavior method.
void ac_behavior( mtlo )
{
  dprintf("mtlo r%d\n", rs);
  RB.write(Lo, RB.read(rs));
  dprintf("Result = %#x\n", RB.read(Lo));
};

//!Instruction j behavior method.
void ac_behavior( j )
{
  dprintf("j %d\n", addr);
  addr = addr << 2;
#ifndef NO_NEED_PC_UPDATE
  ac_pc = delay( (ac_pc & 0xF0000000) | addr , 1);
#endif 
  dprintf("Target = %#x\n", (ac_pc & 0xF0000000) | addr );
};

//!Instruction jal behavior method.
void ac_behavior( jal )
{
  dprintf("jal %d\n", addr);
  // Save the value of PC + 8 (return address) in $ra ($31) and
  // jump to the address given by PC(31...28)||(addr<<2)
  // It must also flush the instructions that were loaded into the pipeline
  RB.write( Ra, ac_pc+4); //ac_pc is pc+4, we need pc+8
	
  addr = addr << 2;
#ifndef NO_NEED_PC_UPDATE
  ac_pc = delay( (ac_pc & 0xF0000000) | addr , 1);
#endif 
	
  dprintf("Target = %#x\n", (ac_pc & 0xF0000000) | addr );
  dprintf("Return = %#x\n", ac_pc+4);
};

//!Instruction jr behavior method.
void ac_behavior( jr )
{
  dprintf("jr r%d\n", rs);
  // Jump to the address stored on the register reg[RS]
  // It must also flush the instructions that were loaded into the pipeline
#ifndef NO_NEED_PC_UPDATE
  ac_pc = delay(RB.read(rs), 1);
#endif 
  dprintf("Target = %#x\n", RB.read(rs));
};

//!Instruction jalr behavior method.
void ac_behavior( jalr )
{
  dprintf("jalr r%d, r%d\n", rd, rs);
  // Save the value of PC + 8(return address) in rd and
  // jump to the address given by [rs]

#ifndef NO_NEED_PC_UPDATE
  ac_pc = delay(RB.read(rs), 1);
#endif 
  dprintf("Target = %#x\n", RB.read(rs));

  if( rd == 0 )  //If rd is not defined use default
    rd = Ra;
  RB.write( rd, ac_pc+4);
  dprintf("Return = %#x\n", ac_pc+4);
};

//!Instruction beq behavior method.
void ac_behavior( beq )
{
  dprintf("beq r%d, r%d, %d\n", rt, rs, imm & 0xFFFF);
  if( RB.read(rs) == RB.read(rt) ){
#ifndef NO_NEED_PC_UPDATE
    ac_pc = delay(ac_pc + (imm<<2), 1);
#endif 
    dprintf("Taken to %#x\n", ac_pc + (imm<<2));
  }	
};

//!Instruction bne behavior method.
void ac_behavior( bne )
{	
  dprintf("bne r%d, r%d, %d\n", rt, rs, imm & 0xFFFF);
  if( RB.read(rs) != RB.read(rt) ){
#ifndef NO_NEED_PC_UPDATE
    ac_pc = delay(ac_pc + (imm<<2), 1);
#endif 
    dprintf("Taken to %#x\n", ac_pc + (imm<<2));
  }	
};

//!Instruction blez behavior method.
void ac_behavior( blez )
{
  dprintf("blez r%d, %d\n", rs, imm & 0xFFFF);
  if( (RB.read(rs) == 0 ) || (RB.read(rs)&0x80000000 ) ){
#ifndef NO_NEED_PC_UPDATE
    ac_pc = delay(ac_pc + (imm<<2), 1);
#endif 
    dprintf("Taken to %#x\n", ac_pc + (imm<<2));
  }	
};

//!Instruction bgtz behavior method.
void ac_behavior( bgtz )
{
  dprintf("bgtz r%d, %d\n", rs, imm & 0xFFFF);
  if( !(RB.read(rs) & 0x80000000) && (RB.read(rs)!=0) ){
#ifndef NO_NEED_PC_UPDATE
    ac_pc = delay(ac_pc + (imm<<2), 1);
#endif 
    dprintf("Taken to %#x\n", ac_pc + (imm<<2));
  }	
};

//!Instruction bltz behavior method.
void ac_behavior( bltz )
{
  dprintf("bltz r%d, %d\n", rs, imm & 0xFFFF);
  if( RB.read(rs) & 0x80000000 ){
#ifndef NO_NEED_PC_UPDATE
    ac_pc = delay(ac_pc + (imm<<2), 1);
#endif 
    dprintf("Taken to %#x\n", ac_pc + (imm<<2));
  }	
};

//!Instruction bgez behavior method.
void ac_behavior( bgez )
{
  dprintf("bgez r%d, %d\n", rs, imm & 0xFFFF);
  if( !(RB.read(rs) & 0x80000000) ){
#ifndef NO_NEED_PC_UPDATE
    ac_pc = delay(ac_pc + (imm<<2), 1);
#endif 
    dprintf("Taken to %#x\n", ac_pc + (imm<<2));
  }	
};

//!Instruction bltzal behavior method.
void ac_behavior( bltzal )
{
  dprintf("bltzal r%d, %d\n", rs, imm & 0xFFFF);
  RB.write( Ra, ac_pc+4); //ac_pc is pc+4, we need pc+8
  if( RB.read(rs) & 0x80000000 ){
#ifndef NO_NEED_PC_UPDATE
    ac_pc = delay(ac_pc + (imm<<2), 1);
#endif 
    dprintf("Taken to %#x\n", ac_pc + (imm<<2));
  }	
  dprintf("Return = %#x\n", ac_pc+4);
};

//!Instruction bgezal behavior method.
void ac_behavior( bgezal )
{
  dprintf("bgezal r%d, %d\n", rs, imm & 0xFFFF);
  RB.write( Ra, ac_pc+4); //ac_pc is pc+4, we need pc+8
  if( !(RB.read(rs) & 0x80000000) ){
#ifndef NO_NEED_PC_UPDATE
    ac_pc = delay(ac_pc + (imm<<2), 1);
#endif 
    dprintf("Taken to %#x\n", ac_pc + (imm<<2));
  }	
  dprintf("Return = %#x\n", ac_pc+4);
};

//!Instruction sys_call behavior method.
void ac_behavior( sys_call )
{
  fprintf(stderr, "syscall behavior not implemented.\n"); exit(EXIT_FAILURE);
}

//!Instruction instr_break behavior method.
void ac_behavior( instr_break )
{
  fprintf(stderr, "instr_break behavior not implemented.\n"); exit(EXIT_FAILURE);
}
