/********************************************************/
/* The ArchC MIPS-I functional model.                   */
/* Author: Sandro Rigo and Marcus Bartholomeu           */
/*                                                      */
/* This file is automatically generated by ArchC        */
/* WITHOUT WARRANTY OF ANY KIND, either express         */
/* or implied.                                          */
/* For more information on ArchC, please visit:         */
/* http://www.archc.org                                 */
/*                                                      */
/* The ArchC Team                                       */
/* Computer Systems Laboratory (LSC)                    */
/* IC-UNICAMP                                           */
/* http://www.lsc.ic.unicamp.br                         */
/********************************************************/
AC_ISA(mips1){


  ac_format Type_R = "%op:6 %rs:5 %rt:5 %rd:5 %shamt:5 %func:6";
  ac_format Type_I  = "%op:6 %rs:5 %rt:5 %imm:16:s";
  ac_format Type_J  = "%op:6 %addr:26";


  ac_instr<Type_I> lb, lbu, lh, lhu, lw, lwl, lwr;
  ac_instr<Type_I> sb, sh, sw, swl, swr;
  ac_instr<Type_I> addi, addiu, slti, sltiu, andi, ori, xori, lui;
  ac_instr<Type_R> add, addu, sub, subu, slt, sltu;
  ac_instr<Type_R> instr_and, instr_or, instr_xor, instr_nor;
  ac_instr<Type_R> nop, sll, srl, sra, sllv, srlv, srav;
  ac_instr<Type_R> mult, multu, div, divu;
  ac_instr<Type_R> mfhi, mthi, mflo, mtlo;
  ac_instr<Type_J> j, jal;
  ac_instr<Type_R> jr, jalr;
  ac_instr<Type_I> beq, bne, blez, bgtz, bltz, bgez, bltzal, bgezal;
  ac_instr<Type_R> sys_call, instr_break;
   
  ISA_CTOR(mips1){
    
    lb.set_asm("lb %rt, %imm(%rs)");
    lb.set_decoder(op=0x20);

    lbu.set_asm("lbu %rt, %imm(%rs)");
    lbu.set_decoder(op=0x24);

    lh.set_asm("lh %rt, %imm(%rs)");
    lh.set_decoder(op=0x21);

    lhu.set_asm("lhu %rt, %imm(%rs)");
    lhu.set_decoder(op=0x25);

    lw.set_asm("lw %rt, %imm(%rs)");
    lw.set_decoder(op=0x23);

    lwl.set_asm("lwl %rt, %imm(%rs)");
    lwl.set_decoder(op=0x22);

    lwr.set_asm("lwr %rt, %imm(%rs)");
    lwr.set_decoder(op=0x26);

    sb.set_asm("sb %rt, %imm(%rs)");
    sb.set_decoder(op=0x28);

    sh.set_asm("sh %rt, %imm(%rs)");
    sh.set_decoder(op=0x29);

    sw.set_asm("sw %rt, %imm(%rs)");
    sw.set_decoder(op=0x2B);

    swl.set_asm("swl %rt, %imm(%rs)");
    swl.set_decoder(op=0x2A);

    swr.set_asm("swr %rt, %imm(%rs)");
    swr.set_decoder(op=0x2E);

    addi.set_asm("addi %rt, %rs, %imm");
    addi.set_decoder(op=0x08);
  
    addiu.set_asm("addiu %rt, %rs, %imm");
    addiu.set_decoder(op=0x09);

    slti.set_asm("slti %rs, %rt, %imm");
    slti.set_decoder(op=0x0A);

    sltiu.set_asm("sltiu %rs, %rt, %imm");
    sltiu.set_decoder(op=0x0B);
  
    andi.set_asm("andi %rt, %rs, %imm");
    andi.set_decoder(op=0x0C);

    ori.set_asm("ori %rt, %rs, %imm");
    ori.set_decoder(op=0x0D);

    xori.set_asm("xori %rt, %rs, %imm");
    xori.set_decoder(op=0x0E);

    lui.set_asm("lui %rt,%imm");
    lui.set_decoder(op=0x0F);

    add.set_asm("add %rs, %rt, %rd");
    add.set_decoder(op=0x00, func=0x20);

    addu.set_asm("addu %rs, %rt, %rd");
    addu.set_decoder(op=0x00, func=0x21);

    sub.set_asm("sub %rs, %rt, %rd");
    sub.set_decoder(op=0x00, func= 0x22);
  
    subu.set_asm("subu %rs, %rt, %rd");
    subu.set_decoder(op=0x00, func= 0x23);

    slt.set_asm("slt %rs, %rt, %rd");
    slt.set_decoder(op=0x00, func= 0x2A);
  
    sltu.set_asm("sltu %rs, %rt, %rd");
    sltu.set_decoder(op=0x00, func= 0x2B);

    instr_and.set_asm("and %rs, %rt, %rd");
    instr_and.set_decoder(op=0x00, func=0x24);

    instr_or.set_asm("or %rs, %rt, %rd");
    instr_or.set_decoder(op=0x00, func=0x25);

    instr_xor.set_asm("instr_xor  %rs, %rt, %rd");
    instr_xor.set_decoder(op=0x00, func=0x26);

    instr_nor.set_asm("instr_nor  %rs, %rt, %rd");
    instr_nor.set_decoder(op=0x00, func=0x27);

    nop.set_asm("nop");
    nop.set_decoder(op=0x00, rd=0x00, func=0x00);
  
    sll.set_asm("sll %rt, %rd, %shamt");
    sll.set_decoder(op=0x00, func= 0x00);
  
    srl.set_asm("srl %rt, %rd, %shamt");
    srl.set_decoder(op=0x00, func= 0x02);
  
    sra.set_asm("sra %rt, %rd, %shamt");
    sra.set_decoder(op=0x00, func= 0x03);
  
    sllv.set_asm("sllv %rt, %rd, %shamt");
    sllv.set_decoder(op=0x00, func= 0x04);
  
    srlv.set_asm("srlv %rt, %rd, %shamt");
    srlv.set_decoder(op=0x00, func= 0x06);
  
    srav.set_asm("srav %rt, %rd, %shamt");
    srav.set_decoder(op=0x00, func= 0x07);
  
    mult.set_asm("mult %rs, %rt");
    mult.set_decoder(op=0x00, func=0x18);

    multu.set_asm("multu %rs, %rt");
    multu.set_decoder(op=0x00, func=0x19);

    div.set_asm("div %rs, %rt");
    div.set_decoder(op=0x00, func=0x1A);

    divu.set_asm("divu %rs, %rt");
    divu.set_decoder(op=0x00, func=0x1B);

    mfhi.set_asm("mfhi %rd");
    mfhi.set_decoder(op=0x00, func=0x10);

    mthi.set_asm("mthi %rs");
    mthi.set_decoder(op=0x00, func=0x11);

    mflo.set_asm("mflo %rd");
    mflo.set_decoder(op=0x00, func=0x12);

    mtlo.set_asm("mflo %rs");
    mtlo.set_decoder(op=0x00, func=0x13);

    j.set_asm("j %addr");
    j.set_decoder(op=0x02);

    jal.set_asm("jal %addr");
    jal.set_decoder(op=0x03);

    jr.set_asm("jr %rs");
    jr.set_decoder(op=0x00, func= 0x08);
  
    jalr.set_asm("jalr %rs");
    jalr.set_decoder(op=0x00, func= 0x09);
  
    beq.set_asm("beq %rs, %rt, %imm");
    beq.set_decoder(op=0x04);
  
    bne.set_asm("bne %rs, %rt, %imm");
    bne.set_decoder(op=0x05);
  
    blez.set_asm("blez %rs, %imm");
    blez.set_decoder(op=0x06);
  
    bgtz.set_asm("bgtz %rs, %imm");
    bgtz.set_decoder(op=0x07); 
  
    bltz.set_asm("bltz %rs, %imm");
    bltz.set_decoder(op=0x01, rt=0x00);
  
    bgez.set_asm("bgez %rs, %imm");
    bgez.set_decoder(op=0x01, rt=0x01);
  
    bltzal.set_asm("bltzal %rs, %imm");
    bltzal.set_decoder(op=0x01, rt=0x10);
  
    bgezal.set_asm("bgezal %rs, %imm");
    bgezal.set_decoder(op=0x01, rt=0x11);
  
    sys_call.set_asm("syscall");
    sys_call.set_decoder(op=0x00, func=0x0C);
  
    instr_break.set_asm("break");
    instr_break.set_decoder(op=0x00, func=0x0D);


/*******************************************************/
/* Optional properties to optimize compiled simulation */
/*******************************************************/


    j.is_jump(((ac_pc+4) & 0xF0000000) | (addr<<2));
    j.delay(1);

    jal.is_jump(((ac_pc+4) & 0xF0000000) | (addr<<2));
    jal.delay(1);
    jal.behavior(RB.write( 31, (ac_pc+4)+4););

    jr.is_jump(RB.read(rs));
    jr.delay(1);

    jalr.is_jump(RB.read(rs));
    jalr.delay(1);
    jalr.behavior(RB.write( ((rd==0)?31:rd), (ac_pc+4)+4););



    beq.is_branch((ac_pc+4) + (imm<<2));
    beq.cond(RB.read(rs) == RB.read(rt));
    beq.delay(1);

    bne.is_branch((ac_pc+4) + (imm<<2));
    bne.cond(RB.read(rs) != RB.read(rt));
    bne.delay(1);

    blez.is_branch((ac_pc+4) + (imm<<2));
    blez.cond((RB.read(rs) == 0 ) || (RB.read(rs)&0x80000000 ));
    blez.delay(1);

    bgtz.is_branch((ac_pc+4) + (imm<<2));
    bgtz.cond(!(RB.read(rs) & 0x80000000) && (RB.read(rs)!=0));
    bgtz.delay(1);

    bltz.is_branch((ac_pc+4) + (imm<<2));
    bltz.cond(RB.read(rs) & 0x80000000);
    bltz.delay(1);

    bgez.is_branch((ac_pc+4) + (imm<<2));
    bgez.cond(!(RB.read(rs) & 0x80000000));
    bgez.delay(1);

    bltzal.is_branch((ac_pc+4) + (imm<<2));
    bltzal.cond(RB.read(rs) & 0x80000000);
    bltzal.delay(1);

    bgezal.is_branch((ac_pc+4) + (imm<<2));
    bgezal.cond(!(RB.read(rs) & 0x80000000));
    bgezal.delay(1);

  };

};